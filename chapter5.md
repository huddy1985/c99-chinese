<meta http-equiv="content-type" content="text/html; charset=UTF-8">
#5. Environment
c语言中编译和执行分属两种不同的环境，分别成为翻译环境和
执行环境。该特性根据c语言的语法和语义规则来定义和限制。

##5.1 Conceptual models
###5.1.1 Translation enviroment
####5.1.1.1 Program structure
一个c程序的代码不需要一次全部编译。代码存储在称作源文件
一个text文本中。通过#include指示符将所有的头文件和源
文件包括在一起，该指示符称作preprocessing translation unit
。经过预处理之后，一个预处理单元称作translation单元。
先前经过处理的translation units可能被保留为一个单独的
文件或者一个库中。这些单独的translation units之间通过
函数调用或者外部符号、对象的方式互相通信。当然translation
units也可能单独的被编译链接成为执行程序。
####5.1.1.2 Translation phases
translation中语法规则的优先级规则通过下文指定：

1. 源文件的字符格式通过预先定义的实现规则映射到源字符集
（引入换行字符和行结束指示符）如果需要的话。三字符被相应
的单字符替换。

2.每个\如果之后紧跟着换行符，将被删除，将物理源码行转换为
逻辑源码行。只有最后一个\才执行上述的操作。一个非空源文件
应该以一个新行结束，该新行不应该与一个\紧邻。

3.源文件被分解为预处理token和一系列的空白字符的序列。该
源文件不应该出现部分token和注释。每个注释被一个空白字符
替换。换行符保留。这种视现方式实具体实现而不同。

4.预处理指示符将被执行，宏被展开，_Pragma一元运算符表
达式被执行。If a character sequence that matches the
syntax of a universal character name is produced by
token concatenation, the behavior is undefined.

例如：

    #define assign(uc1, uc2, val) uc1##uc2 = val
    void func(void)
    {
        int \u0401;
        assign(\u04, 01, 4);
    }
    
\#include预处理指示符触发了从第一步到第四步的整个进程，
整个过程是递归的过程。

5.源文件中每个字符和常量字符中的转译编码会被转换为对应执行
字符编码，如果没有对应的执行字符，这个转换视具体的实现而定。

6.相邻的字符串token会被合并。

7.空格符分割的token不再具有实际意义。每个预处理token都被
转换为token。最后的token经过语法和语义分析之后，转换为translation
 unit。
 
 8.解决所有外部对象和函数引用问题。库中的引用和对象将被链接到合适的
 位置。所有上述的输出被整合到程序镜像中，包括该镜像运行所需的一切。
 
 ####5.1.1.3 Diagnostics
 当预处理或者translation unit中包含一个语法错误或者显示包含未定义
 行为，那么遵守该约定的translation实现应该至少输出一个诊断信息。
 
 example:
 
    char i;
    int i;
    
就应该产生一个诊断信息。

###5.1.2 Execution environments
这里定义了两个执行环境：freestanding和hosted执行环境。
在这两个环境中，c函数的执行环境调用指定函数，启用该程序。
所有静态存储的对象将被初始化在程序启动之前。这个初始化的方式
和时机是未指定的。程序执行结束之后，将控制权返回到执行环境。

####5.1.2.1 Freestanding environment
在一个freestanding的环境中（该环境中，c程序可能不需要任何的操作系统的支持），
执行环境调用c程序的启动函数和类型视具体实现定义。支持c程序执行的库也是视
环境的具体实现而定。
####5.1.2.2 Hosted environments
该环境需要提供如下的执行环境：

#####5.1.2.2.1 Program startup
启动c程序的函数名叫main。具体的实现版本并没有规定该函数的原型。
该原型应该如下：

    int main(void) {/**/}
    
或者带两个参数的函数

    int main(int argc, char *argv[]) {}
    
或者其他实现的方式。

如果定义了函数是带有参数的，那么main函数遵循下述的规定：

    argc非负
    argv[argc]应该是null指针
    如果argc的值大于0，数组成员argv[0]到argv[argc - 1]（包括最后一个）应该
    包含指向字符串的指针，这个指针有hosted env来具体实现。该数组是为了提供
    具体的运行参数。如果该运行环境无法提供大小写都包含的字符串，那么
    应该保证该字符串都是小写。
    如果argc的值大于0，argv[0]指向程序自己的名称。如果hosted environments
    无法提供程序明，那么argv[0][0]应该是一个null字符。argv[1]到argv[argc - 1]
    传递函数参数。
    argv提供的字符串应该可以被程序修改，并且可以在程序执行到结束的期间可以获取。
    
#####5.1.2.2.2 Program execution
在Hosted environments中，一个程序可能使用了所有的函数，宏，类型定义
和对象描述的对象法则。

#####5.1.2.2.3 Program termination
如果main函数的返回类型是int，那么从main函数的返回，相当于调用了exit函数
，参数是main函数返回的值。如果到达}，没有返回值，那么相当于返回了0.如果
返回类型是于int不兼容，那么返回到host environments中的状态是不确定的。

####5.1.2.3 Program execution
在该IS的语义描述中，描述的抽象机器的行为与优化没有任何相关性。

处于执行状态时，访问一个可变对象、修改对象、修改文件或者调用一个函数的行为称作副作用。
计算一个表达式的时候可能产生副作用。在执行序列中，某些指定的点称作序列点，在该点，所有先前
的副作用应该完成，并且在子序列中也没有任何的副作用发生。

    例如：
    extern int i, j;
    i = 0;
    j = i;
    
    上述代码中i = 0以及j = i都是一个完整表达式，而c/c++都规定完整表达式之后有一个序列点

在一台抽象的机器中，如果可以推导出表达式的值不被使用，并且不产生任何的必须的副作用（包括由调用函数或者访问olatile对象引起的任何副作用），则该表达式不会被执行。

当进程执行的时候，忽然接受到一个中断，只有该中断前的序列点的值是可靠的。在这之前序列点的值被修改，但是没有达到下一个序列点，所以没有接受到正确的值。

最有一个需要遵守的需求是：
    
    在一个序列点，volatile对象在上个序列点完成之后是稳定的，下一个访问还没有发生。
    当程序终止的时候，所有写到文件的数据应该于程序结束时候产生的结果是一致的。
    动态交互设备的输入输出应该发生于7.19.3节的说明。这些需求的目的是没有buffered的和line-buffered的内容尽快输出，保证输出的信息在用户等待的输入之前完成。
    
关于交互设备的视具体实现而定。

    example 2 interge promotions
    char c1, c2;
    c1 = c1 + c2;
    该特性要求抽象机器（？）提升每个变量的值到int,并将他们相加，然后截断他们的值。鉴于两个char值的相加可以不溢出的相加，或者溢出但是被处理了，然后产生正确的结果。真正的执行可能根本不需要产生提升。
    
    避免不必要的类型转换。
    
    example 5 rearrangement
    double x, y, z;
    x = (x*y)*z;			// not equal to x*= y*z;
    .....
    不能进行分配率等等的转换。因为roundoff 规则的问题。
    
    例如 -1 % 2 = -1						
            1 % -2 = 1
            
    在C语言中，不能随意调整运算的次序，例如
    a = a + 32760 + b + 5
    ==
    a = (((a + 32760) + b) + 5);
    
    7. 组表达式并不能完全决定他的值。
    例如
    #include <stdio.h>
    int sum;
    char *p;
    
    sum = sum * 10 - '0' + (*p++ = getchar());
    
    表达是分组如下：
    sum = (((sum * 10) - '0') + ((*(p++)) = (getchar())));
    
    但是实际上p++可以发生于任意序列点的时间。函数调用getchar可以发生于任意需要该值的时间点。
    
##5.2 Environmental considerations
###5.2.1 Character sets
源码字符集和执行环境字符集要实现定义完整。每个字符集进一步划分为基本字符集和扩展字符，这总称为扩展字符集。
执行环境字符集由实际的执行环境定义。

执行环境字符集的成员：字符常量或者字符串。应该通过对应的源码字符集来描述，或者通过转译字符串来描述。一个只有0的字符用来表示字符串的结束，称作null character。

基本源码和执行字符集应该包括以下成员：
26个大写的拉丁字母和小写拉丁字母，以及10个阿拉伯数字。
还有以下29个图形字符：

! " # % & ' ( ) * + , - . / :

; < = > ? [ \ ] ^ _ { | } ~

空格符，平行制表符和垂直制表符还有回退等等。


    
